[TOC]

##### 表达式转换

> 中缀表达式转后缀表达式

+ 手算

  1. 确定中缀表达式中各个运算符的顺序
  2. 选择下一个运算符,按照$[$ 左操作数 右操作数 运算符 $]$的方式组合成一个新的操作数
  3. 如果还有运算符没被处理,就继续2

  **左优先原则**:只要左边的运算符能先运算,就先算左边的(保证运算结果唯一)

+ 机算

  初始化一个栈,用于保存**暂时还不能确定运算顺序的运算符**

  从左到右处理各个元素,直到末尾,可能遇到三种情况

  1. 遇到**操作数**:直接加入后缀表达式
  2. 遇到**界限符**:遇到'`(`'直接入栈,遇到'`)`'则依次弹出栈内运算符并加入后缀表达式,直到弹出'`(`'为止.**注意:'('不加入后缀表达式**
  3. 遇到**运算符**.依次弹出栈中优先级高于或等于当前运算符的所有运算符,并加入后缀表达式,若碰到'('或栈空则停止.之后再把当前运算符入栈

> 中缀表达式转前缀表达式

+ 手算

  1. 确定中缀表达式中各个运算符的顺序
  2. 选择下一个运算符,按照$[$ 运算符 左操作数 右操作数  $]$的方式组合成一个新的操作数
  3. 如果还有运算符没被处理,就继续2

  **右优先原则**:只要左边的运算符能先运算,就先算右边的(保证运算结果唯一)



##### 表达式运算

+ 后缀表达式的运算(机算)

  1. 从左往右扫描下一个元素,直到处理完所有元素

  2. 若扫描到操作数则压入栈,并回到1;否则执行3

  3. 若扫描到运算符,则弹出两个栈顶元素,执行相应运算,运算结果压回栈顶,回到1

  **注意:3中先出栈的是右操作数**

  若表达式合法,则最后栈中只会留下一个元素,就是最终结果

+ 前缀表达式的运算(机算)

  1. 从右往左扫描下一个元素,直到处理完所有元素

  2. 若扫描到操作数则压入栈,并回到1;否则执行3

  3. 若扫描到运算符,则弹出两个栈顶元素,执行相应运算,运算结果压回栈顶,回到1

  **注意:3中先出栈的是左操作数**

  若表达式合法,则最后栈中只会留下一个元素,就是最终结果r

一棵树的后根遍历序列和它对应的二叉树的中序遍历序列相同

森林的先序遍等同于对各个树进行先根遍历,也等同于对应二叉树的先序遍历

森林的中序遍等同于对各个树进行后根遍历,也等同于对应二叉树的中序遍历

DFS可以实现逆拓扑排序

#### 第6章:图

+ 简单路径: 顶点不重复出现的路径
+ 连通分量: 无向图的极大连通子图称为连通分量

+ 生成树: 连通图的生成树是包含图中全部顶点的一个极小连通子图

##### 图的遍历

+ 深度优先遍历
  + 可以通过是否有回边判断图中是否有环
+ 广度优先

##### 最小生成树

+ Prim算法
  + 时间复杂度: $O(|V|^2)$
+ Kruskal算法
  + 时间复杂度: $O(|E|\log|E|)$

##### 最短路径问题

> 最短路径一定是简单路径
>
> 以下三种方法均解决不了带有负权值回路的图

+ BFS
  + 只能处理无权或所有边权值相同的图
+ Dijkstra算法
  + 不能处理带负权值边的图
  + 时间复杂度:$O(|V|^2)$

+ Floyd算法
  + 需要当前路径长度矩阵和path中转点矩阵
  + 时间复杂度: $O(|V|^3)$
+ 拓扑排序
  + 适用于DAG图
  + 可以用于判断图中是否有环

+ 关键路径
  + 在AOE网中,从源点到汇点的路径长度最大的路径称为关键路径,其上的活动称为==关键活动==

